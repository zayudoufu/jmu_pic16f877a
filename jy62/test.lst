     1: #include<pic.h>
     2: #include<stdint.h>
     3: __CONFIG(0xFF29);     //芯片配置位定义
     4: char data[20];
     5: char useful[20];
     6: float calaculate[30];
     7: short datax,datay,dataz;
     8: float buff,buf;
     9: int x1,x2,x3,x4,x5;
    10: int a1,a2,a3,a4,K;
    11: int flag=0,n=0;
    12: static volatile char table[16]={0x30,0x31,0x32,0x33,0x34,0x35,
    13: 0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46};
    14: 
    15: void DELAY()
    16: {unsigned int i;for(i=999;i>0;i--);}
    17: void ENABLE()//写入控制命令的子程序
    18: { RA5=0; RA4=0;RA3=0;DELAY();RA3=1;}
    19: void ENABLE1()//写入字的子程序
    20: { RA5=1; RA4=0;RA3=0;DELAY();RA3=1;}
    21: 
    22: void div()
    23: {
    24:         if(buff<0){flag=1;buff=-buff;}  //buff为short有正负之分所以这里判断是否为负数
    25:         else flag=0;                                    //若为负数标志位flag置1否则清0
    26:         buf=buff*18000/32768;                   //将buff换成角度并扩大100倍数
    27:         x1=buf/10000;a1=buf-x1*10000;   //计算第一位
    28:         x2=a1/1000;a2=a1-x2*1000;       //计算第二位
    29:         x3=a2/100;a3=a2-x3*100;                 //计算第三位
    30:         x4=a3/10;a4=a3-x4*10;                   //计算第四位
    31:         x5=a4;                                                  //计算第五位
    32: }
    33: 
    34: 
    35: void interrupt usart_seve() 
    36: {
    37: 
    38:                 data[n]=RCREG;
    39:                 if(data[0]!=0x55)n=0;   //判断data[0]是否为协议头若不是则重新接收
    40:                 TXREG=useful[n];            //将useful数据发送给电脑
    41:                 while(!TRMT);               //等待发送完毕
    42:                 if(data[0]==0x55)n++;   //若data[0]为协议头则可以接收全部
    43:                 if(n>=11)n=0;                   //当接收完11位后重新开始下一轮
    44: 
    45: }
    46: 
    47: main()
    48: {
    49:         TRISD=0; TRISA=0;ADCON1=7;//定义端口方向
    50:         DELAY(); //调用延时,刚上电 LCD 复位不一定有 PIC 快
    51:         PORTD=1;ENABLE(); //清屏
    52:         PORTD=0x38;ENABLE(); //8 位 2 行 5x7 点阵
    53:         PORTD=0x0c;ENABLE(); //显示器开、光标不开、闪烁不开
    54:         PORTD=0x06;ENABLE(); //文字不动，光标自动右移
    55:         TRISC=0xff;PORTC=0xff;
    56:         SPBRG=25;//转载波特率发生器，约为9600kbd
    57:         TXSTA=0B00100100;//使能USART发送，波特率发生器为高速方式
    58:         RCSTA=0B10010000;//连续接收
    59:         GIE=1;PEIE=1;RCIE=1;//开放USART接收中断
    60: while(1)
    61: {
    62:         if(data[1]==0x53 && data[0]==0x55)//判断协议头和数据内容
    63:         {for(int i=0;i<11;i++){useful[i]=data[i];}};//若符合要求则将数组data前11个的数据赋值给数组useful
    64:         datax=(short)((short)useful[3]<<8|useful[2]);//将角度X数据强制转换成short类型高低位合并赋值给datax
    65:         buff=datax;div();
    66:         PORTD=0x80; ENABLE(); //光标指向第 1 行的位置
    67:         PORTD='R'; ENABLE1(); //角度X
    68:         if(flag==1){PORTD='-'; ENABLE1();} //标志位若为1则输出一个符号否则输出空格
    69:         else {PORTD=' '; ENABLE1();}
    70:         PORTD=table[x1]; ENABLE1();//输出第一位
    71:         PORTD=table[x2]; ENABLE1();//输出第二位
    72:         PORTD=table[x3]; ENABLE1();//输出第三位
    73:         PORTD='.'; ENABLE1();
    74:         PORTD=table[x4]; ENABLE1();//输出第四位
    75:         PORTD=table[x5]; ENABLE1();//输出第五位
    76:         PORTD=' '; ENABLE1();
    77:         datay=(useful[5]<<8|useful[4]);//将角度Y数据强制转换成short类型高低位合并赋值给datay
    78:         buff=datay;div();
    79:         PORTD='P'; ENABLE1();//角度Y
    80:         if(flag==1){PORTD='-'; ENABLE1();}
    81:         else {PORTD=' '; ENABLE1();}
    82:         PORTD=table[x1]; ENABLE1();
    83:         PORTD=table[x2]; ENABLE1();
    84:         PORTD=table[x3]; ENABLE1();
    85:         PORTD='.'; ENABLE1();
    86:         PORTD=table[x4]; ENABLE1();
    87:         K=x5;    //由于lcd一行不够用 则将角度Y的第二位小数赋值给K到最后输出
    88:         //PORTD=table[x5]; ENABLE1();
    89:         PORTD=' '; ENABLE1();
    90:         dataz=(useful[7]<<8|useful[6]);//将角度Z数据强制转换成short类型高低位合并赋值给dataz
    91:         buff=dataz;div();
    92:         PORTD=0xC0; ENABLE(); //光标指向第 2 行的位置
    93:         PORTD='Y'; ENABLE1();//角度Z
    94:         if(flag==1){PORTD='-'; ENABLE1();}
    95:         else {PORTD=' '; ENABLE1();}
    96:         PORTD=table[x1]; ENABLE1();
    97:         PORTD=table[x2]; ENABLE1();
    98:         PORTD=table[x3]; ENABLE1();
    99:         PORTD='.'; ENABLE1();
   100:         PORTD=table[x4]; ENABLE1();
   101:         PORTD=table[x5]; ENABLE1();
   102:         PORTD=' '; ENABLE1();
   103:         PORTD=0xCF; ENABLE(); 
   104:         PORTD=table[K]; ENABLE1();//角度Y的第二位小数
   105: }